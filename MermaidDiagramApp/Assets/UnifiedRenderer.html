<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Content Renderer</title>
    <style>
        :root {
            --bg-color: #222;
            --text-color: #fff;
            --link-color: #58a6ff;
            --border-color: #444;
            --code-bg: #1e1e1e;
            
            /* User-customizable Markdown styling */
            --md-font-size: 16px;
            --md-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            --md-line-height: 1.6;
            --md-max-width: 900px;
            --md-code-font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            --md-code-font-size: 14px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        body.light-theme {
            --bg-color: #ffffff;
            --text-color: #24292f;
            --link-color: #0969da;
            --border-color: #d0d7de;
            --code-bg: #f6f8fa;
        }

        #content-container {
            width: 100%;
            max-width: 100%;
            overflow: auto;
        }

        /* Mermaid-specific styles */
        #content-container.mermaid-mode {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: calc(100vh - 40px);
            text-align: center;
        }

        /* Markdown-specific styles */
        #content-container.markdown-mode {
            max-width: var(--md-max-width);
            margin: 0 auto;
        }
        
        /* Allow Mermaid to handle text layout naturally - removed forced wrapping CSS */
        /* The previous CSS was forcing text to wrap at 250-280px which caused unnecessary line breaks */

        .markdown-body {
            font-size: var(--md-font-size);
            font-family: var(--md-font-family);
            line-height: var(--md-line-height);
        }

        .markdown-body h1, .markdown-body h2 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
            margin-top: 24px;
            margin-bottom: 16px;
        }

        .markdown-body h1 { font-size: 2em; }
        .markdown-body h2 { font-size: 1.5em; }
        .markdown-body h3 { font-size: 1.25em; }

        .markdown-body a {
            color: var(--link-color);
            text-decoration: none;
        }

        .markdown-body a:hover {
            text-decoration: underline;
        }

        .markdown-body code {
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: var(--md-code-font-family);
            font-size: var(--md-code-font-size);
        }

        .markdown-body pre {
            background-color: var(--code-bg);
            padding: 16px;
            border-radius: 6px;
            overflow: auto;
        }

        .markdown-body pre code {
            background-color: transparent;
            padding: 0;
            font-family: var(--md-code-font-family);
            font-size: var(--md-code-font-size);
        }

        .markdown-body table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }

        .markdown-body table th,
        .markdown-body table td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
        }

        .markdown-body table tr:nth-child(even) {
            background-color: rgba(128, 128, 128, 0.1);
        }

        .markdown-body blockquote {
            border-left: 4px solid var(--border-color);
            padding-left: 16px;
            margin-left: 0;
            color: #888;
        }

        .markdown-body ul, .markdown-body ol {
            padding-left: 2em;
        }

        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        .markdown-body .task-list-item {
            list-style-type: none;
        }

        .markdown-body .task-list-item input[type="checkbox"] {
            margin-right: 0.5em;
        }

        .error {
            color: #ff6b6b;
            white-space: pre-wrap;
            padding: 20px;
            background-color: rgba(255, 107, 107, 0.1);
            border-radius: 6px;
            margin: 20px 0;
        }

        #debug-info {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow: auto;
            display: none;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="content-container">
        <div id="loading-placeholder">Loading renderer...</div>
    </div>
    <div id="debug-info"></div>
    
    <script>
        // Logging utility
        window.log = function() {
            const args = Array.from(arguments);
            console.log(...args);
            
            if (window.chrome && window.chrome.webview) {
                window.chrome.webview.postMessage({
                    type: 'log',
                    message: args.map(arg => 
                        typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
                    ).join(' ')
                });
            }
            
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) {
                const line = document.createElement('div');
                line.textContent = args.join(' ');
                debugInfo.appendChild(line);
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        };
        
        // Toggle debug panel with Ctrl+Shift+D
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo) {
                    debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
                }
            }
        });
        
        // Intercept keyboard shortcuts for the host application
        // Use capture phase (third parameter = true) to intercept before other handlers
        document.addEventListener('keydown', (e) => {
            // Handle F11 (with or without Ctrl)
            if (e.key === 'F11') {
                e.preventDefault();
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'keypress',
                        key: 'F11',
                        ctrlKey: e.ctrlKey,
                        shiftKey: e.shiftKey,
                        altKey: e.altKey
                    });
                }
                return false;
            }
            
            // Handle Escape
            if (e.key === 'Escape') {
                e.preventDefault();
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'keypress',
                        key: 'Escape',
                        ctrlKey: e.ctrlKey,
                        shiftKey: e.shiftKey,
                        altKey: e.altKey
                    });
                }
                return false;
            }
            
            // Handle F7
            if (e.key === 'F7') {
                e.preventDefault();
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'keypress',
                        key: 'F7',
                        ctrlKey: e.ctrlKey,
                        shiftKey: e.shiftKey,
                        altKey: e.altKey
                    });
                }
                return false;
            }
            
            // Handle F5 (Presentation Mode and Refresh Preview)
            if (e.key === 'F5') {
                e.preventDefault();
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'keypress',
                        key: 'F5',
                        ctrlKey: e.ctrlKey,
                        shiftKey: e.shiftKey,
                        altKey: e.altKey
                    });
                }
                return false;
            }
        }, true); // Use capture phase to intercept before browser handles them

        // Load libraries
        async function loadLibraries() {
            log('Loading rendering libraries...');
            
            // Load Mermaid
            await loadScript('mermaid.min.js', 'https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js');
            
            // Load markdown-it
            await loadScript('markdown-it.min.js', 'https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js');
            
            // Load highlight.js for code syntax highlighting
            await loadScript('highlight.min.js', 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/highlight.min.js');
            
            log('All libraries loaded successfully');
        }

        function loadScript(localPath, cdnUrl) {
            return new Promise((resolve, reject) => {
                const localScript = document.createElement('script');
                localScript.src = localPath;
                
                localScript.onload = () => {
                    log(`Loaded ${localPath} from local`);
                    resolve();
                };
                
                localScript.onerror = () => {
                    log(`Failed to load ${localPath} locally, trying CDN...`);
                    const cdnScript = document.createElement('script');
                    cdnScript.src = cdnUrl;
                    
                    cdnScript.onload = () => {
                        log(`Loaded from CDN: ${cdnUrl}`);
                        resolve();
                    };
                    
                    cdnScript.onerror = () => {
                        const error = `Failed to load ${localPath} from both local and CDN`;
                        log(error);
                        reject(new Error(error));
                    };
                    
                    document.head.appendChild(cdnScript);
                };
                
                document.head.appendChild(localScript);
            });
        }

        // Initialize libraries
        async function init() {
            try {
                await loadLibraries();
                
                // Initialize Mermaid with configuration to avoid foreignObject issues
                if (typeof mermaid !== 'undefined') {
                    const config = {
                        startOnLoad: false,
                        securityLevel: 'loose',
                        theme: 'dark',
                        logLevel: 3,
                        // CRITICAL: Disable automatic text wrapping (Mermaid v10.1.0+)
                        markdownAutoWrap: false,
                        // Disable text wrapping for subgraph titles
                        flowchart: { 
                            htmlLabels: true,
                            useMaxWidth: true,
                            // Remove wrappingWidth to prevent unnecessary text wrapping
                            // wrappingWidth: 200  // REMOVED - was causing titles to wrap
                        },
                        sequence: { 
                            htmlLabels: false,
                            useMaxWidth: true
                        },
                        gantt: { 
                            htmlLabels: false,
                            useMaxWidth: true
                        },
                        themeVariables: {
                            fontSize: '14px',
                            fontFamily: 'arial, sans-serif'
                        }
                    };
                    
                    try {
                        mermaid.initialize(config);
                        log('Mermaid initialized with config:', JSON.stringify(config));
                        
                        // Verify the configuration was applied
                        const currentConfig = mermaid.getConfig();
                        log('Current Mermaid config:', JSON.stringify(currentConfig));
                        
                        // Send configuration to host for verification
                        if (window.chrome && window.chrome.webview) {
                            window.chrome.webview.postMessage({
                                type: 'mermaidConfigured',
                                config: currentConfig
                            });
                        }
                    } catch (error) {
                        log('Error initializing Mermaid:', error);
                    }
                }
                
                // Initialize markdown-it
                if (typeof markdownit !== 'undefined') {
                    window.md = markdownit({
                        html: true,
                        linkify: true,
                        typographer: true,
                        highlight: function (str, lang) {
                            if (lang && typeof hljs !== 'undefined' && hljs.getLanguage(lang)) {
                                try {
                                    return hljs.highlight(str, { language: lang }).value;
                                } catch (__) {}
                            }
                            return '';
                        }
                    });
                    log('markdown-it initialized');
                }
                
                // Notify host that we're ready
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({ type: 'ready' });
                }
                
                const container = document.getElementById('content-container');
                container.innerHTML = '<div style="color:#888;">Ready to render content</div>';
                
            } catch (error) {
                const errorMsg = `Initialization failed: ${error.message || error}`;
                log(errorMsg);
                document.getElementById('content-container').innerHTML = 
                    `<div class="error">${errorMsg}</div>`;
            }
        }

        // Render Mermaid diagram
        window.renderMermaid = async function(content, theme = 'dark') {
            const container = document.getElementById('content-container');
            container.className = 'mermaid-mode';
            
            if (!content || !content.trim()) {
                container.innerHTML = '<div style="color:#888;">No content to render</div>';
                return;
            }
            
            log('Rendering Mermaid diagram...');
            container.innerHTML = '<div>Rendering diagram...</div>';
            
            try {
                // Re-initialize with better configuration
                mermaid.initialize({
                    startOnLoad: false,
                    securityLevel: 'loose',
                    theme: theme.toLowerCase(),
                    logLevel: 3,
                    // CRITICAL: Disable automatic text wrapping (Mermaid v10.1.0+)
                    markdownAutoWrap: false,
                    flowchart: { 
                        htmlLabels: true, 
                        useMaxWidth: true,
                        // Remove wrappingWidth to prevent title wrapping
                        // wrappingWidth: 300,  // REMOVED
                        nodeSpacing: 80,
                        rankSpacing: 80,
                        padding: 20
                    },
                    sequence: { htmlLabels: false },
                    gantt: { htmlLabels: false },
                    class: { htmlLabels: false },
                    state: { htmlLabels: false }
                });
                
                log('Mermaid re-initialized for render');
                
                const { svg } = await mermaid.render('mermaid-diagram-' + Date.now(), content);
                
                // Check if SVG contains foreignObject
                if (svg.includes('<foreignObject')) {
                    log('WARNING: SVG still contains foreignObject despite htmlLabels: false!');
                    log('This may be a Mermaid.js version issue or theme override');
                } else {
                    log('SUCCESS: SVG does not contain foreignObject');
                }
                
                container.innerHTML = svg;
                
                log('Mermaid diagram rendered successfully');
                
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'renderComplete',
                        mode: 'mermaid',
                        hasForeignObject: svg.includes('<foreignObject')
                    });
                }
            } catch (error) {
                const errorMsg = `Mermaid rendering failed: ${error.message || error}`;
                log(errorMsg);
                container.innerHTML = `<div class="error">${errorMsg}</div>`;
                
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'renderError',
                        error: error.message
                    });
                }
            }
        };
        
        // DISABLED: Let Mermaid handle all text layout naturally
        // The previous fix was causing unnecessary text wrapping
        function fixSubgraphTitleOverflow(container) {
            // Do nothing - Mermaid handles text layout correctly by default
            log('fixSubgraphTitleOverflow: DISABLED - letting Mermaid handle text layout');
        }
        
        // REMOVED: splitTextForDisplay function - no longer needed
        // Mermaid handles text layout correctly by default

        // Update style settings dynamically
        window.updateStyleSettings = function(settings) {
            try {
                const root = document.documentElement;
                if (settings.fontSize) root.style.setProperty('--md-font-size', settings.fontSize + 'px');
                if (settings.fontFamily) root.style.setProperty('--md-font-family', settings.fontFamily);
                if (settings.lineHeight) root.style.setProperty('--md-line-height', settings.lineHeight);
                if (settings.maxContentWidth) root.style.setProperty('--md-max-width', settings.maxContentWidth > 0 ? settings.maxContentWidth + 'px' : '100%');
                if (settings.codeFontFamily) root.style.setProperty('--md-code-font-family', settings.codeFontFamily);
                if (settings.codeFontSize) root.style.setProperty('--md-code-font-size', settings.codeFontSize + 'px');
                log('Style settings updated');
            } catch (error) {
                log('Error updating style settings:', error.message);
            }
        };

        // Resolve local image paths
        window.resolveImagePath = function(imagePath, baseFilePath) {
            if (!imagePath || imagePath.startsWith('http://') || imagePath.startsWith('https://') || imagePath.startsWith('data:')) {
                return imagePath;
            }
            
            try {
                // Handle relative paths
                if (baseFilePath && !imagePath.startsWith('/')) {
                    const basePath = baseFilePath.substring(0, baseFilePath.lastIndexOf('\\'));
                    const resolvedPath = basePath + '\\' + imagePath.replace(/\//g, '\\');
                    return 'file:///' + resolvedPath.replace(/\\/g, '/');
                }
                
                // Handle absolute paths
                if (imagePath.match(/^[a-zA-Z]:\\/)) {
                    return 'file:///' + imagePath.replace(/\\/g, '/');
                }
                
                return imagePath;
            } catch (error) {
                log('Error resolving image path:', error.message);
                return imagePath;
            }
        };

        // Render Markdown content
        window.renderMarkdown = async function(content, enableMermaid = true, theme = 'dark', styleSettings = null, baseFilePath = '') {
            const container = document.getElementById('content-container');
            container.className = 'markdown-mode';
            
            if (!content || !content.trim()) {
                container.innerHTML = '<div style="color:#888;">No content to render</div>';
                return;
            }
            
            log('Rendering Markdown content...');
            
            try {
                // Update theme
                document.body.className = theme.toLowerCase() === 'light' ? 'light-theme' : '';
                
                // Update style settings if provided
                if (styleSettings) {
                    window.updateStyleSettings(styleSettings);
                }
                
                // Render Markdown to HTML
                const html = window.md.render(content);
                container.innerHTML = `<div class="markdown-body">${html}</div>`;
                
                // Resolve local image paths
                if (baseFilePath) {
                    const images = container.querySelectorAll('img');
                    images.forEach(img => {
                        const originalSrc = img.getAttribute('src');
                        const resolvedSrc = window.resolveImagePath(originalSrc, baseFilePath);
                        if (resolvedSrc !== originalSrc) {
                            img.setAttribute('src', resolvedSrc);
                            log(`Resolved image: ${originalSrc} -> ${resolvedSrc}`);
                        }
                    });
                }
                
                // Render embedded Mermaid diagrams if enabled
                if (enableMermaid) {
                    const mermaidBlocks = container.querySelectorAll('code.language-mermaid');
                    
                    if (mermaidBlocks.length > 0) {
                        log(`Found ${mermaidBlocks.length} Mermaid code blocks`);
                        
                        // Update Mermaid theme
                        if (mermaid.initialize) {
                            mermaid.initialize({
                                startOnLoad: false,
                                securityLevel: 'loose',
                                theme: theme.toLowerCase(),
                                logLevel: 1,
                                // CRITICAL: Disable automatic text wrapping
                                markdownAutoWrap: false,
                                // Disable HTML labels to avoid foreignObject issues
                                flowchart: { htmlLabels: false },
                                sequence: { htmlLabels: false },
                                gantt: { htmlLabels: false },
                                journey: { htmlLabels: false },
                                timeline: { htmlLabels: false },
                                class: { htmlLabels: false },
                                state: { htmlLabels: false },
                                er: { htmlLabels: false },
                                pie: { htmlLabels: false }
                            });
                        }
                        
                        for (let i = 0; i < mermaidBlocks.length; i++) {
                            const block = mermaidBlocks[i];
                            const code = block.textContent;
                            
                            try {
                                const { svg } = await mermaid.render(`mermaid-${i}-${Date.now()}`, code);
                                
                                // Fix z-order to ensure text labels appear above lines
                                const fixedSvg = window.fixSvgZOrder(svg, theme);
                                
                                const div = document.createElement('div');
                                div.innerHTML = fixedSvg;
                                div.style.textAlign = 'center';
                                div.style.margin = '20px 0';
                                
                                // Apply subgraph title fix to embedded diagrams
                                fixSubgraphTitleOverflow(div);
                                
                                block.parentElement.replaceWith(div);
                            } catch (error) {
                                log(`Failed to render Mermaid block ${i}:`, error.message);
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'error';
                                errorDiv.textContent = `Mermaid diagram error: ${error.message}`;
                                block.parentElement.replaceWith(errorDiv);
                            }
                        }
                    }
                }
                
                log('Markdown rendered successfully');
                
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'renderComplete',
                        mode: 'markdown'
                    });
                }
            } catch (error) {
                const errorMsg = `Markdown rendering failed: ${error.message || error}`;
                log(errorMsg);
                container.innerHTML = `<div class="error">${errorMsg}</div>`;
                
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage({
                        type: 'renderError',
                        error: error.message
                    });
                }
            }
        };

        // Unified rendering function
        window.renderContent = async function(content, mode, enableMermaid = true, theme = 'dark', styleSettings = null, baseFilePath = '') {
            log(`Rendering content in ${mode} mode`);
            
            if (mode === 'mermaid') {
                await window.renderMermaid(content, theme);
            } else if (mode === 'markdown') {
                await window.renderMarkdown(content, enableMermaid, theme, styleSettings, baseFilePath);
            } else {
                log(`Unknown rendering mode: ${mode}`);
            }
        };

        // Fix SVG z-order to ensure text labels appear above lines
        window.fixSvgZOrder = function(svgString, theme = 'dark') {
            try {
                log('=== Fixing SVG z-order and edge label backgrounds ===');
                log('Theme:', theme);
                log('SVG length:', svgString.length);
                
                // Parse the SVG string into a DOM
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgString, 'image/svg+xml');
                const svg = doc.querySelector('svg');
                
                if (!svg) {
                    log('ERROR: No SVG element found, returning original');
                    return svgString;
                }
                
                // Determine background color based on theme
                const bgColor = theme === 'light' ? '#ffffff' : '#222222';
                log('Using background color:', bgColor);
                
                // Log SVG structure for debugging
                const allGroups = svg.querySelectorAll('g');
                log(`Total groups in SVG: ${allGroups.length}`);
                allGroups.forEach((g, i) => {
                    const className = g.getAttribute('class') || '(no class)';
                    const id = g.getAttribute('id') || '(no id)';
                    log(`  Group ${i}: class="${className}", id="${id}"`);
                });
                
                // Step 1: Fix edge label backgrounds
                const edgeLabelGroups = svg.querySelectorAll('g.edgeLabel');
                log(`Found ${edgeLabelGroups.length} edge label groups`);
                
                let labelsFixed = 0;
                
                edgeLabelGroups.forEach((edgeLabelGroup, index) => {
                    // Find the rect inside the label group
                    const rect = edgeLabelGroup.querySelector('rect');
                    const text = edgeLabelGroup.querySelector('text');
                    
                    log(`  Label ${index}: rect=${!!rect}, text=${!!text}`);
                    
                    if (rect && text) {
                        // Set the rect to have a solid background
                        rect.setAttribute('fill', bgColor);
                        rect.setAttribute('fill-opacity', '1.0');
                        rect.setAttribute('stroke', '#666');
                        rect.setAttribute('stroke-width', '1');
                        
                        // Add a small padding by expanding the rect
                        const x = parseFloat(rect.getAttribute('x') || '0');
                        const y = parseFloat(rect.getAttribute('y') || '0');
                        const width = parseFloat(rect.getAttribute('width') || '0');
                        const height = parseFloat(rect.getAttribute('height') || '0');
                        
                        log(`  Label ${index} original rect: x=${x}, y=${y}, w=${width}, h=${height}`);
                        
                        const padding = 4;
                        rect.setAttribute('x', (x - padding).toString());
                        rect.setAttribute('y', (y - padding).toString());
                        rect.setAttribute('width', (width + padding * 2).toString());
                        rect.setAttribute('height', (height + padding * 2).toString());
                        
                        labelsFixed++;
                    }
                });
                
                log(`Fixed ${labelsFixed} edge label backgrounds`);
                
                // Step 2: Fix z-order by moving ALL label-related elements to the end
                // Strategy: Find all groups and move labels/nodes to the end
                
                // Get the root group or SVG element to work with
                const rootElement = svg.querySelector('g') || svg;
                log(`Working with root element: ${rootElement.tagName}`);
                
                // Collect all elements that should be on top
                const elementsToMoveToTop = [];
                
                // Find all edge paths first (these should stay at the bottom)
                const edgePaths = Array.from(rootElement.querySelectorAll('g.edgePath, path.edge, path[class*="edge"]'));
                log(`Found ${edgePaths.length} edge paths (will stay at bottom)`);
                
                // Find all label elements (these should be on top)
                const edgeLabels = Array.from(rootElement.querySelectorAll('g.edgeLabel'));
                const nodeLabels = Array.from(rootElement.querySelectorAll('g.nodeLabel, g.label'));
                const nodes = Array.from(rootElement.querySelectorAll('g.node'));
                
                log(`Found elements to move to top:`);
                log(`  - ${edgeLabels.length} edge labels`);
                log(`  - ${nodeLabels.length} node labels`);
                log(`  - ${nodes.length} nodes`);
                
                // Combine all elements that should be on top
                elementsToMoveToTop.push(...edgeLabels, ...nodeLabels, ...nodes);
                
                // Remove duplicates
                const uniqueElements = [...new Set(elementsToMoveToTop)];
                log(`Total unique elements to reorder: ${uniqueElements.length}`);
                
                if (uniqueElements.length > 0) {
                    // Move each element to the end of its parent
                    let movedCount = 0;
                    uniqueElements.forEach((element, index) => {
                        const parent = element.parentNode;
                        if (parent) {
                            log(`  Moving element ${index}: ${element.tagName}.${element.getAttribute('class') || '(no class)'}`);
                            parent.removeChild(element);
                            parent.appendChild(element);
                            movedCount++;
                        }
                    });
                    log(`Successfully moved ${movedCount} elements to top`);
                } else {
                    log('WARNING: No elements found to reorder - SVG structure may be different than expected');
                    log('Attempting alternative approach...');
                    
                    // Alternative: Look for any text elements and move them to the end
                    const allTextElements = Array.from(svg.querySelectorAll('text'));
                    log(`Found ${allTextElements.length} text elements`);
                    
                    if (allTextElements.length > 0) {
                        allTextElements.forEach((textEl, index) => {
                            const parent = textEl.parentNode;
                            if (parent && parent.tagName === 'g') {
                                // Move the parent group to the end
                                const grandParent = parent.parentNode;
                                if (grandParent) {
                                    log(`  Moving text parent group ${index}`);
                                    grandParent.removeChild(parent);
                                    grandParent.appendChild(parent);
                                }
                            }
                        });
                        log('Moved text element parent groups to top');
                    }
                }
                
                // Serialize back to string
                const serializer = new XMLSerializer();
                const fixedSvg = serializer.serializeToString(svg);
                
                log('=== SVG processing completed ===');
                log('Fixed SVG length:', fixedSvg.length);
                
                return fixedSvg;
            } catch (error) {
                log('ERROR fixing SVG:', error.message);
                log('Stack trace:', error.stack);
                return svgString; // Return original on error
            }
        };

        // Get current SVG (for export)
        window.getSvg = function() {
            // First check if we have an export SVG stored
            if (window._exportSvg) {
                return window._exportSvg;
            }
            
            // Otherwise get the current SVG from the container
            const container = document.getElementById('content-container');
            const svg = container.querySelector('svg');
            return svg ? svg.outerHTML : '';
        };

        // Render Mermaid for export without affecting current preview
        window.renderMermaidForExport = async function(content, theme = 'light') {
            log('Rendering Mermaid diagram for export...');
            
            try {
                // Store current container content
                const container = document.getElementById('content-container');
                const originalContent = container.innerHTML;
                const originalClassName = container.className;
                
                // Temporarily switch to mermaid mode for rendering
                container.className = 'mermaid-mode';
                container.innerHTML = '<div>Rendering for export...</div>';
                
                // Update theme for export rendering
                if (mermaid.initialize) {
                    mermaid.initialize({
                        startOnLoad: false,
                        securityLevel: 'loose',
                        theme: theme.toLowerCase(),
                        logLevel: 1,
                        // CRITICAL: Disable automatic text wrapping
                        markdownAutoWrap: false,
                        // Disable HTML labels to avoid foreignObject issues during export
                        flowchart: { htmlLabels: false },
                        sequence: { htmlLabels: false },
                        gantt: { htmlLabels: false },
                        journey: { htmlLabels: false },
                        timeline: { htmlLabels: false },
                        class: { htmlLabels: false },
                        state: { htmlLabels: false },
                        er: { htmlLabels: false },
                        pie: { htmlLabels: false }
                    });
                }
                
                // Render the diagram
                const { svg } = await mermaid.render('export-diagram-' + Date.now(), content);
                
                // Fix z-order to ensure text labels appear above lines
                const fixedSvg = window.fixSvgZOrder(svg, theme);
                
                // Store the fixed SVG for retrieval
                window._exportSvg = fixedSvg;
                
                // Restore original content immediately
                container.innerHTML = originalContent;
                container.className = originalClassName;
                
                log('Mermaid diagram rendered for export successfully');
                
                return svg;
            } catch (error) {
                const errorMsg = `Mermaid export rendering failed: ${error.message || error}`;
                log(errorMsg);
                window._exportSvg = '';
                throw error;
            }
        };

        // Start initialization
        init();
    </script>
</body>
</html>
